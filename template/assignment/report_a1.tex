\documentclass[11pt,a4paper]{../template/report}

\assignment{1}
\group{G052}
\students{Bette Jonas}{Huet Anatole}

\begin{document}

\maketitle

\section{Python AIMA (3 pts)}

\begin{enumerate}
  \item In order to perform a search, what are the classes that you must define or extend? Explain precisely why and where they are used inside a \textit{tree\_search}. Be concise! (e.g. do not discuss unchanged classes). \textbf{(1 pt)}
\end{enumerate}

\begin{answer}
% Your answer here
Pour effectuer une recherche, il faut définir la classe \textit{Problem} avec les méthodes \textit{actions}, \textit{result} et \textit{goal\_test}. Elles sont utilisées dans \textit{tree\_search} pour connaître ce que PacMan peut faire et fera à chaque état.
\end{answer}



\begin{enumerate}
\setcounter{enumi}{1}
    \item Both \textit{breadth\_first\_graph\_search} and \textit{depth\_first\_graph\_search} are making a call to the same function. How is their fundamental difference implemented (be explicit)? \textbf{(0.5 pt)}
\end{enumerate}

\begin{answer}
% Your answer here
\textit{Breadth\_first\_graph\_search} utilise une Queue qui est une structure FIFO, tandis que \textit{depth\_first\_graph\_search} utilise une Stack qui elle est une structure LIFO. Ce ne sont donc pas les mêmes valeurs qui en resortiront, le premier sort les valeurs dans l'ordre où elles sont entrées, tandis que le second sort les dernières valeurs entrées en premier.
\end{answer}



\begin{enumerate}
\setcounter{enumi}{2}
    \item What is the difference between the implementation of the \textit{graph\_search} and the \textit{tree\_search} methods and how does it impact the search methods? \textbf{(0.5 pt)}
\end{enumerate}

\begin{answer}
% Your answer here
Un \textit{graph\_search} va garder en mémoire les états déjà visités pour ne pas les revisiter, évitant ainsi une boucle infinie. \\
Un \textit{tree\_search} ne le fait pas et de ce fait requiert moins de mémoire.
\end{answer}



\begin{enumerate}
\setcounter{enumi}{3}
    \item What kind of structure is used to implement the \textit{reached nodes minus the frontier list}? What properties must thus have the elements that you can
	put inside the reached nodes minus the frontier list? \textbf{(0.5 pt)}
\end{enumerate}

\begin{answer}
% Your answer here
\end{answer}



\begin{enumerate}
\setcounter{enumi}{4}
    \item How technically can you use the implementation of the reached nodes minus the frontier list to deal with symmetrical states? (hint: if two symmetrical states are considered by the algorithm to be the same, they will not be visited twice) \textbf{(0.5 pt)}
\end{enumerate}

\begin{answer}
% Your answer here
\end{answer}




\section{The 
PacMan Problem (17 pts)}

\begin{enumerate}
\setcounter{enumi}{1}
\begin{enumerate}
\item \textbf{Describe} the set of possible actions your agent will consider at each state. Evaluate the branching factor\textbf{(1 pt)}
\end{enumerate}
  
\end{enumerate}

\begin{answer}
% Your answer here
La taille d'une grille est de "n x m", le nombre d'actions possibles maximales est de "n + m - 2". En effet, sans mur, PacMan peut se déplacer en ligne droite jusqu'au bord de la grille. Donc, sans compter l'emplacement où il se situe, il a "n + m - 2" cases où il peut s'arrêter. \\
Le facteur de branchement quant à lui est aussi de "n + m - 2". On peut avoir maximum "n + m - 2" positions pour PacMan donc si on construit un arbre, chaque noeud aura au maximum "n + m - 2" enfants.
\end{answer}
\begin{enumerate}
\setcounter{enumi}{1}
\begin{enumerate}
\setcounter{enumii}{1}
    \item  How would you build the action to avoid the walls? \textbf{(1 pt)}
\end{enumerate}
  
\end{enumerate}

\begin{answer}
% Your answer here
Pour éviter les murs, on peut simplement vérifier si la case où PacMan veut se déplacer est un mur. Si c'est le cas, on arrête la vérification des espaces libres et on retourne celles qu'on vérifiées.
\end{answer}



\begin{enumerate}
\setcounter{enumi}{1}
    \item \textbf{Problem analysis.}
    \begin{enumerate}
        \item Explain the advantages and weaknesses of the following search strategies \textbf{on this problem} (not in general): depth first, breadth first. Which approach would you choose? \textbf{(2 pts)}
    \end{enumerate}
\end{enumerate}

\begin{answer}
% Your answer here
\end{answer}



\begin{enumerate}
\setcounter{enumi}{1}
\begin{enumerate}
\setcounter{enumii}{1}
    \item What are the advantages and disadvantages of using the tree and graph search \textbf{for this problem}. Which approach would you choose? \textbf{(2 pts)}
\end{enumerate}
\end{enumerate}

\begin{answers}[4cm]
% Your answer here
En utilisant un graphe, on évite de visiter plusieurs fois le même état, ce qui est un avantage car on gagne du temps. Cependant, on utilise plus de mémoire pour stocker les états déjà visités. \\
En utilisant un arbre, on risque de tomber dans une boucle infinie car on ne garde pas en mémoire les états déjà visités pour gagner de la place. On peut donc se retrouver à visiter plusieurs fois le même état . \\
Pour ce problème, on choisirait d'utiliser un graphe car on a un nombre fini d'états et on ne risque pas de tomber dans une boucle infinie.
\end{answers}



\begin{enumerate}
\setcounter{enumi}{2}
    \item \textbf{Implement} a PacMan solver in Python 3.
			You shall extend the \emph{Problem} class and implement the necessary methods -and other class(es) if necessary- allowing you to test the following four different approaches: 
			\begin{itemize}
			\item \textit{depth-first tree-search (DFSt)};
			\item \textit{breadth-first tree-search (BFSt)};
			\item \textit{depth-first graph-search (DFSg)};
			\item \textit{breadth-first graph-search (BFSg)}. 
			\end{itemize}

    \textbf{Experiments} must be realized (\textit{not yet on INGInious!} use your own computer or one from the computer rooms) with the provided 10 instances. Report in a table the results on the 10 instances for depth-first and breadth-first strategies on both tree and graph search (4 settings above). Run each experiment for a maximum of 1 minute. You must report the time, the number of explored nodes as well as the number of remaining nodes in the queue to get a solution. \textbf{(4 pts)}
\end{enumerate}

\begin{answers}[7cm]
% Your answer here
\small
\begin{center}
\begin{tabular}{||l|l|l|l|l|l|l|l|l|l|l|l|l||}
\hline
\multirow{3}{*}{Inst.} & \multicolumn{6}{c|}{BFS} & \multicolumn{6}{c||}{DFS} \\
\cline{2-13}
& \multicolumn{3}{c|}{Tree} & \multicolumn{3}{c|}{Graph} & \multicolumn{3}{c|}{Tree} & \multicolumn{3}{c||}{Graph}\\
\cline{2-13}
 & T(s) & EN & RNQ & T(s) & EN & RNQ & T(s) & EN & RNQ & T(s) & EN & RNQ\\
\hline
i\_01 & 0.07 & 116 & 1421 & 0.005 & 9 & 106 & N/A & N/A & N/A & N/A & N/A & N/A \\
\hline
i\_02 & 0.03 & 96 & 861 & 0.003 & 9 & 86 & N/A & N/A & N/A & N/A & N/A & N/A \\
\hline
i\_03 & N/A & N/A & N/A & N/A & N/A & N/A & N/A & N/A & N/A & N/A & N/A & N/A \\
\hline
i\_04 & N/A & N/A & N/A & N/A & N/A & N/A & N/A & N/A & N/A & N/A & N/A & N/A \\
\hline
i\_05 & 3.29 & 6849 & 66352 & 0.3 & 692 & 6156 & N/A & N/A & N/A & N/A & N/A & N/A \\
\hline
i\_06 & 0.05 & 283 & 2282 & 0.007 & 32 & 250 & N/A & N/A & N/A & N/A & N/A & N/A \\
\hline
i\_07 & 0.47 & 2157 & 16410 & 0.06 & 247 & 1909 & N/A & N/A & N/A & N/A & N/A & N/A \\
\hline
i\_08 & 0.008 & 89 & 451 & 0.001 & 16 & 72 & N/A & N/A & N/A & N/A & N/A & N/A \\
\hline
i\_09 & 0.02 & 76 & 581 & 0.003 & 11 & 64 & N/A & N/A & N/A & N/A & N/A & N/A \\
\hline
i\_10 & 0.03 & 96 & 861 & 0.003 & 9 & 86 & N/A & N/A & N/A & N/A & N/A & N/A \\
\hline
\end{tabular}
\end{center}
\textbf{T}: Time — \textbf{EN}: Explored nodes —
\textbf{RNQ}: Remaining nodes in the queue — \textbf{N/A}: Timeout
\end{answers}



\begin{enumerate}
\setcounter{enumi}{3}
    \item \textbf{Submit} your program (encoded in \textbf{utf-8}) on INGInious. According to your experimentations, it must use the algorithm that leads to the best results. Your program must take as inputs the four numbers previously described separated by space character, and print to the standard output a solution to the problem satisfying the format described in Figure 3. Under INGInious (only 1 minute timeout per instance!), we expect you to solve at least 12 out of the 15 ones. \textbf{(6 pts)}
\end{enumerate}

\begin{enumerate}
\setcounter{enumi}{4}
\item \textbf{Conclusion.}
\begin{enumerate}
        \item How would you handle the case of some fruit that is poisonous and makes
you lose?
\textbf{(0.5 pt)}
\end{enumerate}

\end{enumerate}

\begin{answer}
% Your answer here
Si on voit que le fruit est empoisonné, on peut simplement le considérer comme une case vide et donc passer au dessus sans s'y arrêter.
\end{answer}

\begin{enumerate}
\setcounter{enumi}{4}
\begin{enumerate}
\setcounter{enumii}{4}
        \item  Do you see any improvement directions for the best algorithm you chose? (Note that since we're still in uninformed search, \textit{we're not talking about informed heuristics}). \textbf{(0.5 pt)}
\end{enumerate}

\end{enumerate}

\begin{answer}
% Your answer here
\end{answer}

\end{document}
